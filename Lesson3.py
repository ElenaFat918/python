# def f(x):
#     x**2

# g = f
# print(type(f)) #<class 'function'>
# print(f(2))
# print(g(2))

# def f(x):  # в контексте нашего приложения у нас есть переменная, которая хранит в себе функцию
#     return x**2
# g = f # пусть есть некая переменная g и в нее я кладу переменную функцию f
# print(type(f))     # <class 'function'> у функции есть тип, а значит мы можжем создать переменную типа функция и соответственно положить в эту переменную какую либо функцию
# print(f(4))
# print(g(4))

# рассмотрим такое приложение:
# пусть функция calc, которая в качестве аргумента принимаетчисло:

# def calc1(x):
#     return x + 10

# # print(calc1(10))

# def calc2(x):
#     return x * 10

# # print(calc2(10))

# def math(op, x):
#     print(op(x))

# math(calc2, 10) #у нас есть calc2, который умножает число на 10
# # в момент вызова функции math, в качестве op будет функция calc2, в качестве аргумента число 10
# math(calc1, 10) 

# попробуем описать логику функции с двумя переменными:
# def sum(x, y):
#     return x + y


# def mult(x, y):
#     return x * y

# def calc(op, a, b):
#     print(op(a, b))
#     # return op(a, b)
# calc(lambda x, y: x + y, 4, 5) #указываем как аргумент op - целую фукцию и те значения, с которыми будет работать функция

#   LIST COMPREHENSION чтобы быстро создавать списки
# Создадим список четных чисел от 1 до 100

# list = []

# for i in range(1, 101):
#      if(i%2 == 0):
#         list.append(i)
# print(list)

# list = [i for i in range(1, 21) if i%2 == 0]
# print(list)

# # Подключаем кортежи:
# list = [(i, i) for i in range(1, 21) if i%2 == 0]
# print(list)
# обработка данных применяя функии и выполняя действия

# def f(x):
#     return x**3
# list = [(i, f(i)) for i in range(1, 21) if i%2 == 0]# к определенной выборке возводится число в степень 3
# print(list)


# list = [1, 2, 3, 5, 8, 15, 23, 38]
# f = lambda x: x**2
# result = [(list[i], f(list[i])) for i in range (len(list)) if list[i]%2==0]
# print(result) 

# with open ('lesson3.txt','r') as f:
#     data = f.read() + ' ' # счиываю всё, что есть в строчке и искусственно добавляю пробел

# # path = '\C:\gitEduc\python\lesson3.txt'
# # f = open(path, 'r')
# # data = f.read() + ' '
# # f.close()

# numbers = [] #создаю пустой список, который буду наполнять в дальнейшем

# while data != '':   # пробегаюсь по всей нашей строке, которую считали на предидущем этапе и делаю проверку пока моя строка не пустая
#     space_pos = data.index(' ') # найти первую позицию пробела
#     numbers.append(int(data[:space_pos])) # взять всё, что находится от 1го символа до позиции первого пробела, превратить это в число и положить в список
#     data = data[space_pos+1:]   # обновить нашу строку с учетом того, что теперь то что мы уже обработали не  нужно использовать

# out = [] #  создаю пустой список, который буду наполнять в дальнейшем
# for e in numbers:   # пробежавшись по списку
#     if not e % 2:   # проверяю что число является четным
#         out.append((e, e **2))  #   добавив в новый список кортеж , где в качестве первой координаты выступает число, а второй его квадрат
# print(out)

# Можно ли как то улучшить код:
# def select(f, col): #   опишем некоторую фцнкцию select, которая будет проинимать ункцию и набор данных
#     return [f(x) for x in col] #    формируем и возвращаем список, в качестве логики будет 

# def where(f, col):      #   некая функция, кот. в качестве аргумента принимает условие по коорому нужно будет произвести фильтрацию обьектов
#     return [x for x in col if f(x)]

# data = '1 2 3 5 8 15 23 38'.split() # получаем набор строк

# res = select(int, data) #   сохраним результат работы функции f, где в качестве первого аргумента передаваться функция преобразования строк в число, а в качестве наора данных data
# res = where(lambda x: not x % 2, res) #  четные в res
# res = select(lambda x: (x, x**2), res) #  кортеж числа и квадраты из res
# print(res)

# _____________________________________________________________________________________
# Функция map принимает на вход функцию,
# которую нужно применить к каждому элементу итерируемого объекта и 
# возвращает итератор с новыми объектами
# _______________________________________________________________________________
# li = [x for x in range(1, 20)]
# li = list(map(lambda x: x + 10, li))
# print(li)

# data = list(map(int,input().split(','))) #    запятая в качестве разделителя, по умолчанию используются пробелЫ, int превращает лист из строк в лист из чисел
# print(data) #   вводим 2,34,5,67,89 и получаем [2, 34, 5, 67, 89]

# data = list(map(int,'1 2 3'.split()))

# for e in data:
#     print(e)

# print('__')

# for e in data:
#     print(e)

#   подправим код еще раз:



#   убираем select, она лишь урезанная версия map

# def where(f, col):      #   некая функция, кот. в качестве аргумента принимает условие по коорому нужно будет произвести фильтрацию обьектов
#     return [x for x in col if f(x)]

# data = '1 2 3 5 8 15 23 38'.split() # получаем набор строк

# res = map(int, data) #   сохраним результат работы функции f, где в качестве первого аргумента передаваться функция преобразования строк в число, а в качестве наора данных data
# res = where(lambda x: not x % 2, res) #  четные в res
# res = list(map(lambda x: (x, x**2), res)) #  кортеж числа и квадраты из res
# print(res)
# _______________________________________________________________________
# Функция filter принимает на вход функцию, отвечающую за логику обработки данных
# и вторым аргументом принимает эти данные
# возвращает итератор с true объектами
# __________________________________________________________________________________
# data = [x for x in range(10)]

# res = list(filter(lambda x: not x % 2, data)) # сделаем выборку в res положим аргумент - lamda, проверяющую явл ли число четным и набор данных data 
# print(res)

#   подправим код еще раз:

#   убираем where, она лишь урезанная версия filter

# data = '1 2 3 5 8 15 23 38'.split() # получаем набор строк

# res = map(int, data) #   сохраним результат работы функции f, где в качестве первого аргумента передаваться функция преобразования строк в число, а в качестве наора данных data
# res = filter(lambda x: not x % 2, res) #  четные в res
# res = list(map(lambda x: (x, x**2), res)) #  кортеж числа и квадраты из res
# print(res)

# ___________________________________________________________________________________
# Функция zip() позволяет получить новый набор данных на осное некоторого количества имеющихся набор
# в качестве аргумента  zip принимает набор данных
# возвращает итератор  кортежами из элементов входных данных
# _________________________________________________________________________________________




# users = ['user1', 'user2', 'user3', 'user4', 'user5']
# ids = [4, 5, 9, 14, 7]
# salary = [111, 222, 333]

# data = list(zip(users, ids, salary))
# print(data) # получились кортежи из элементов входных данных[('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)]

# ___________________________________________________________________________________________
# Функция enumerate принимает набор данных . а на выходе получаем кортежи 
# с явно пронумерованными элементами
# _______________________________________________________________________________________________ 
  
# users = ['user1', 'user2', 'user3', 'user4', 'user5']
# data = list(enumerate(users))
# print(data)     #   [(0, 'user1'), (1, 'user2'), (2, 'user3'), (3, 'user4'), (4, 'user5')]

# ___________________________________________________________________________________
# Функции сортировки

# sp = ['df', 'jejger', 'asd', 'zz']
# # sp.sort()   #   сортирует по алфавиту, преобразуется сам список
# print(sp)
# print(sorted(sp))   #   сам список не преобразуется, а лишь временно применяется функция
# print(sorted(sp, key=lambda x: len(x)))     #   добавили ключ: у списка sp перебираем элементы, называя их х, берем их длину и по параметру длины сортируем их по возрастанию и в алфавитном порядке
# print(sorted(sp, key=lambda x: -len(x)))    #   по убыванию
# print(sorted(sp, key=lambda x: (len(x), -ord(x[0]))))    #   по убыванию и обратном порядке алфавита
# # или отсортируем против алфавита и потом отсортируем по длине:
# sp.sort(reverse=True)
# print(sorted(sp, key=lambda x: len(x))) 
# print(sp)